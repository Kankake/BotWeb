import fs from 'fs'
import express from 'express'
import path, { dirname, resolve } from 'path'
import { fileURLToPath } from 'url'
import { Telegraf, Markup } from 'telegraf'
import XLSX from 'xlsx'
import fetch from 'node-fetch'
import dotenv from 'dotenv'

dotenv.config();

console.log('ğŸš€ Bot starting up...');
console.log('Environment check:', {
  PORT: process.env.PORT,
  WEBAPP_URL: process.env.WEBAPP_URL,
  MYSQL_HOST: process.env.MYSQL_HOST,
  MYSQL_DBNAME: process.env.MYSQL_DBNAME,
  BOT_TOKEN: process.env.BOT_TOKEN ? 'SET' : 'NOT SET',
  ADMIN_CHAT_ID: process.env.ADMIN_CHAT_ID ? 'SET' : 'NOT SET'
});

const __filename = fileURLToPath(import.meta.url)
const __dirname  = dirname(__filename)

// Initialize Express app - ADD THIS SECTION
const app = express();
app.use(express.json());
app.use(express.static('public'));

const WELCOME_PHOTO = path.join(__dirname, 'public', 'assets', 'welcome.jpg');
const NEXT_PHOTO = path.join(__dirname, 'public', 'assets', 'next.jpg');

// Load config from .env
const BOT_TOKEN = process.env.BOT_TOKEN;
const ADMIN_CHAT_ID = process.env.ADMIN_CHAT_ID;
const WEBAPP_URL = process.env.WEBAPP_URL;
const PORT = process.env.PORT || 3000;
const WEBHOOK_PATH = '/tg-webhook';

// Ğ¾Ğ±ÑŠÑĞ²Ğ»ÑĞµĞ¼ pool Ğ·Ğ°Ñ€Ğ°Ğ½ĞµĞµ
let pool


let schedules = {}; // Ğ³Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ğ°Ñ

const awaitingScheduleUpload = new Set();
const awaitingCustomName = new Set();
const awaitingBroadcast = new Set();
const pendingReminders = new Map();
const pendingBookings = new Map();

// In-memory storage as fallback
const users = new Map();
const userNames = new Map();

if (!BOT_TOKEN || !ADMIN_CHAT_ID || !WEBAPP_URL) {
  console.error('âŒ Missing BOT_TOKEN, ADMIN_CHAT_ID or WEBAPP_URL');
  process.exit(1);
}

// Database functions with fallback to memory
async function initDatabase() {
  // Skip MySQL initialization, use only memory storage
  console.log('âš ï¸ Using memory storage only');
  return;
}


async function addUser(userId, firstName, username) {
  if (pool) {
    try {
      await pool.execute(
        'INSERT INTO bot_users (user_id, first_name, username) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE first_name = VALUES(first_name), username = VALUES(username)',
        [userId, firstName || '', username || '']
      );
      console.log(`ğŸ‘¤ User added/updated in DB: ${userId}`);
      return;
    } catch (err) {
      console.error('âŒ Failed to add user to DB:', err);
    }
  }
  
  // Fallback to memory
  users.set(userId, { firstName, username, addedAt: new Date() });
  console.log(`ğŸ‘¤ User added/updated in memory: ${userId}`);
}

async function getUsersCount() {
  if (pool) {
    try {
      const [rows] = await pool.execute('SELECT COUNT(*) as count FROM bot_users');
      return parseInt(rows[0].count);
    } catch (err) {
      console.error('âŒ Failed to get users count from DB:', err);
    }
  }
  
  return users.size;
}

async function getAllUsers() {
  if (pool) {
    try {
      const [rows] = await pool.execute('SELECT user_id FROM bot_users');
      return rows.map(row => row.user_id);
    } catch (err) {
      console.error('âŒ Failed to get all users from DB:', err);
    }
  }
  
  return Array.from(users.keys());
}

async function removeUser(userId) {
  if (pool) {
    try {
      await pool.execute('DELETE FROM bot_users WHERE user_id = ?', [userId]);
      console.log(`ğŸ‘¤ User removed from DB: ${userId}`);
      return;
    } catch (err) {
      console.error('âŒ Failed to remove user from DB:', err);
    }
  }
  
  users.delete(userId);
  userNames.delete(userId);
  console.log(`ğŸ‘¤ User removed from memory: ${userId}`);
}

async function setUserName(chatId, name) {
  if (pool) {
    try {
      await pool.execute(
        'INSERT INTO user_names (chat_id, custom_name) VALUES (?, ?) ON DUPLICATE KEY UPDATE custom_name = VALUES(custom_name), updated_at = CURRENT_TIMESTAMP',
        [chatId, name]
      );
      return;
    } catch (err) {
      console.error('âŒ Failed to set user name in DB:', err);
    }
  }
  
  userNames.set(chatId, name);
}

async function getUserName(chatId) {
  if (pool) {
    try {
      const [rows] = await pool.execute('SELECT custom_name FROM user_names WHERE chat_id = ?', [chatId]);
      return rows[0]?.custom_name || null;
    } catch (err) {
      console.error('âŒ Failed to get user name from DB:', err);
    }
  }
  
  return userNames.get(chatId) || null;
}

async function saveSchedules(schedulesData) {
  if (pool) {
    try {
      await pool.execute('DELETE FROM schedules');
      
      for (const [address, scheduleArray] of Object.entries(schedulesData)) {
        await pool.execute(
          'INSERT INTO schedules (address, schedule_data) VALUES (?, ?)',
          [address, JSON.stringify(scheduleArray)]
        );
      }
      console.log('âœ… Schedules saved to MySQL database');
      return;
    } catch (err) {
      console.error('âŒ Failed to save schedules to DB:', err);
    }
  }
  
  schedules = schedulesData;
  console.log('âœ… Schedules saved to memory');
}

async function loadSchedules() {
  if (pool) {
    try {
      const [rows] = await pool.execute('SELECT address, schedule_data FROM schedules');
      const loadedSchedules = {};
      
      for (const row of rows) {
        loadedSchedules[row.address] = JSON.parse(row.schedule_data);
      }
      
      console.log(`âœ… Loaded schedules for ${Object.keys(loadedSchedules).length} addresses from DB`);
      return loadedSchedules;
    } catch (err) {
      console.error('âŒ Failed to load schedules from DB:', err);
    }
  }
  
  return {};
}

// Initialize database
await initDatabase();

// Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ½Ğ° Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°
async function isAdminUser(ctx) {
  return ctx.chat.id.toString() === ADMIN_CHAT_ID;
}

// Initialize bot
const bot = new Telegraf(BOT_TOKEN);

// Add error handler
bot.catch((err, ctx) => {
  console.error('âŒ Bot error:', err);
});

// Add debug middleware
bot.use((ctx, next) => {
  console.log('ğŸ“¨ Received:', ctx.updateType, 'from:', ctx.from?.id);
  return next();
});

// Function to send a message to a user and handle blocked users
async function sendMessageToUser(userId, message) {
  try {
    await bot.telegram.sendMessage(userId, message);
  } catch (error) {
    if (error.code === 403) {
      console.error(`User ${userId} has blocked the bot. Removing from database.`);
      await removeUser(userId);
    } else {
      console.error(`Failed to send message to user ${userId}:`, error.message);
    }
  }
}

// Function to update schedule from buffer
async function updateScheduleFromBuffer(buffer) {
  try {
    console.log('ğŸ“Š Starting to process Excel buffer...');
    
    const workbook = XLSX.read(buffer, { type: 'buffer' });
    const sheet = workbook.Sheets[workbook.SheetNames[0]];
    const data = XLSX.utils.sheet_to_json(sheet);
    
    console.log('ğŸ“Š Raw data from Excel:', data.length, 'rows');

    const newSchedules = {};
    let processedRows = 0;
    let errorRows = 0;

    data.forEach((row, index) => {
      try {
        if (!row.date || !row.time || !row.direction || !row.address) {
          console.log(`âš ï¸ Row ${index + 1} missing required fields`);
          errorRows++;
          return;
        }

        let dateValue = row.date;
        
        if (typeof dateValue === 'number') {
          dateValue = new Date((dateValue - 25569) * 86400 * 1000);
        } else {
          dateValue = new Date(dateValue);
        }
        
        if (isNaN(dateValue.getTime())) {
          console.log(`âš ï¸ Row ${index + 1} invalid date:`, row.date);
          errorRows++;
          return;
        }
        
        const formattedDate = dateValue.toISOString().split('T')[0];
        const address = row.address.toString().trim();

        if (!newSchedules[address]) {
          newSchedules[address] = [];
        }

        const orderedEntry = {
          date: formattedDate,
          time: row.time.toString().trim(),
          direction: row.direction.toString().trim(),
          address: address
        };

        newSchedules[address].push(orderedEntry);
        processedRows++;
        
      } catch (error) {
        console.error(`âŒ Error processing row ${index + 1}:`, error);
        errorRows++;
      }
    });

    await saveSchedules(newSchedules);
    schedules = newSchedules;
    
    console.log('âœ… Schedules updated successfully');

    return { newSchedules, processedRows, errorRows };
    
  } catch (error) {
    console.error('âŒ Error in updateScheduleFromBuffer:', error);
    throw error;
  }
}

// Set up menu commands
try {
  const publicCommands = [
    { command: 'start', description: 'ĞĞ°Ñ‡Ğ°Ñ‚ÑŒ Ğ·Ğ°Ğ½Ğ¾Ğ²Ğ¾' },
    { command: 'contacts', description: 'ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹ ÑÑ‚ÑƒĞ´Ğ¸Ğ¸' }
  ];
  await bot.telegram.setMyCommands(publicCommands);

  const adminGroupCommands = [
    { command: 'update_schedule', description: 'ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ñ€Ğ°ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ' },
    { command: 'cancel_schedule', description: 'ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºÑƒ Ñ€Ğ°ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ' },
    { command: 'users_count', description: 'ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹' },
    { command: 'broadcast', description: 'Ğ Ğ°ÑÑÑ‹Ğ»ĞºĞ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ' },
    { command: 'check_schedules', description: 'ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ñ€Ğ°ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ' }
  ];
  await bot.telegram.setMyCommands(adminGroupCommands, {
    scope: { type: 'chat', chat_id: Number(ADMIN_CHAT_ID) }
  });

} catch (err) {
  console.log('Command menu setup error:', err);
}

bot.start(async ctx => {
  const firstName = ctx.from.first_name || 'ĞºĞ»Ğ¸ĞµĞ½Ñ‚';
  const username = ctx.from.username || '';
  const chatId = ctx.chat.id;
  const userId = ctx.from.id;
  
  await addUser(userId, firstName, username);
  await setUserName(chatId, firstName);
  
  // Clear existing reminders
  if (pendingReminders.has(chatId)) {
    const {t3, t15, t24 } = pendingReminders.get(chatId);
    clearTimeout(t3);
    clearTimeout(t15);
    clearTimeout(t24);
  }
  
  // Set new reminders
  const t15 = setTimeout(() => {
    bot.telegram.sendMessage(
      chatId,
      `${firstName}, ÑƒÑĞ¿ĞµĞ¹Ñ‚Ğµ Ğ²Ğ¾ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒÑÑ Ğ±ĞµÑĞ¿Ğ»Ğ°Ñ‚Ğ½Ñ‹Ğ¼ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¼ Ğ·Ğ°Ğ½ÑÑ‚Ğ¸ĞµĞ¼ Ğ² Ğ½Ğ°ÑˆĞµĞ¹ ÑÑ‚ÑƒĞ´Ğ¸Ğ¸ ğŸ’›.\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¾Ğ±Ğ½Ğ¾Ğµ Ğ·Ğ°Ğ½ÑÑ‚Ğ¸Ğµ, Ğ¿Ğ¾ĞºĞ° Ğ¸Ñ… Ğ½Ğµ Ñ€Ğ°Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ»Ğ¸ ğŸ™ˆ`,
      Markup.inlineKeyboard([
        Markup.button.webApp('Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½', WEBAPP_URL)
      ])
    );
  }, 15 * 60 * 1000);

  const t3 = setTimeout(() => {
    bot.telegram.sendMessage(
      chatId,
      `ğŸ‘‹ ĞŸÑ€Ğ¸Ğ²ĞµÑ‚, ${firstName}! ğŸƒâ€â™€ï¸ ĞœĞµÑÑ‚Ğ° Ğ½Ğ° Ğ±ĞµÑĞ¿Ğ»Ğ°Ñ‚Ğ½Ğ¾Ğµ Ğ¿Ñ€Ğ¾Ğ±Ğ½Ğ¾Ğµ Ğ·Ğ°Ğ½ÑÑ‚Ğ¸Ğµ Ğ·Ğ°ĞºĞ°Ğ½Ñ‡Ğ¸Ğ²Ğ°ÑÑ‚ÑÑ â€” ÑƒÑĞ¿ĞµĞ¹ Ğ·Ğ°Ğ±Ñ€Ğ¾Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑĞ²Ğ¾Ñ‘!`,
      Markup.inlineKeyboard([
        Markup.button.webApp('Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½', WEBAPP_URL)
      ])
    );
  }, 3 * 60 * 60 * 1000);

  const t24 = setTimeout(() => {
    bot.telegram.sendMessage(
      chatId, 
      `${firstName}, ÑƒÑĞ¿ĞµĞ¹Ñ‚Ğµ Ğ²Ğ¾ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒÑÑ Ğ±ĞµÑĞ¿Ğ»Ğ°Ñ‚Ğ½Ñ‹Ğ¼ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¼ Ğ·Ğ°Ğ½ÑÑ‚Ğ¸ĞµĞ¼ Ğ² Ğ½Ğ°ÑˆĞµĞ¹ ÑÑ‚ÑƒĞ´Ğ¸Ğ¸ ğŸ’›.\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¾Ğ±Ğ½Ğ¾Ğµ Ğ·Ğ°Ğ½ÑÑ‚Ğ¸Ğµ, Ğ¿Ğ¾ĞºĞ° Ğ¸Ñ… Ğ½Ğµ Ñ€Ğ°Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ»Ğ¸ ğŸ™ˆ`,
      Markup.inlineKeyboard([
        Markup.button.webApp('Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒÑÑ Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½', WEBAPP_URL)
      ])
    );
  }, 24 * 60 * 60 * 1000);

  pendingReminders.set(chatId, {t3, t15, t24 });

  await ctx.replyWithPhoto({ source: WELCOME_PHOTO });
  
  await ctx.reply(
    `ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ÑÑ‚Ğ²ÑƒÑ, Ğ½Ğ°Ñˆ Ğ±ÑƒĞ´ÑƒÑ‰Ğ¸Ğ¹ ĞºĞ»Ğ¸ĞµĞ½Ñ‚!\n` +
    `Ğ¯ Ğ›ĞµÑ â€” ÑƒĞ¼Ğ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰Ğ½Ğ¸Ğº ÑÑ‚ÑƒĞ´Ğ¸Ğ¸ Ğ±Ğ°Ğ»ĞµÑ‚Ğ° Ğ¸ Ñ€Ğ°ÑÑ‚ÑĞ¶ĞºĞ¸ LEVITA!\n\n` +
    `ĞœĞ¾Ğ³Ñƒ Ğ¾Ğ±Ñ€Ğ°Ñ‰Ğ°Ñ‚ÑŒÑÑ Ğº Ğ²Ğ°Ğ¼ Ğ¿Ğ¾ Ğ¸Ğ¼ĞµĞ½Ğ¸ "${firstName}", ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾ Ñƒ Ğ²Ğ°Ñ Ğ² Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ğµ?`,
    Markup.keyboard([['Ğ”Ğ°', 'ĞĞµÑ‚, Ğ²Ğ²ĞµÑÑ‚Ğ¸ Ğ´Ñ€ÑƒĞ³Ğ¾Ğµ Ğ¸Ğ¼Ñ']])
      .resize()
      .oneTime()
  );
});

bot.hears('Ğ”Ğ°', async ctx => {
  await ctx.replyWithPhoto({ source: NEXT_PHOTO });
  
  return ctx.reply(
    'ĞÑ‚Ğ»Ğ¸Ñ‡Ğ½Ğ¾! Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ:',
    Markup.keyboard([
      ['ğŸ–¥ï¸ Ğ—Ğ°Ğ¿Ğ¸ÑÑŒ Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½', 'ğŸ“ Ğ—Ğ°Ğ¿Ğ¸ÑÑŒ Ğ¿Ğ¾ Ğ·Ğ²Ğ¾Ğ½ĞºÑƒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°'],
      ['ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹']
    ])
    .resize()
  );
});

bot.hears('ğŸ–¥ï¸ Ğ—Ğ°Ğ¿Ğ¸ÑÑŒ Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½', ctx => {
  ctx.reply(
    'Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚Ğµ Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½-Ñ„Ğ¾Ñ€Ğ¼Ñƒ:',
    Markup.inlineKeyboard([
      Markup.button.webApp('ĞŸĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğº Ñ„Ğ¾Ñ€Ğ¼Ğµ', WEBAPP_URL)
    ])
  );
});

bot.hears('ğŸ“ Ğ—Ğ°Ğ¿Ğ¸ÑÑŒ Ğ¿Ğ¾ Ğ·Ğ²Ğ¾Ğ½ĞºÑƒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°', ctx => {
  return ctx.reply(
    'ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ğ¾Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒÑÑ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ğ¾Ğ¼, Ğ¸ Ğ¼Ñ‹ Ğ²Ğ°Ğ¼ Ğ¿ĞµÑ€ĞµĞ·Ğ²Ğ¾Ğ½Ğ¸Ğ¼.',
    Markup.keyboard([
      ['â¬…ï¸ ĞĞ°Ğ·Ğ°Ğ´', {text: 'ğŸ“² ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚', request_contact: true}]
    ])
    .resize()
  );
});

bot.hears('â¬…ï¸ ĞĞ°Ğ·Ğ°Ğ´', ctx => {
  return ctx.reply(
    'Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ:',
    Markup.keyboard([
      ['ğŸ–¥ï¸ Ğ—Ğ°Ğ¿Ğ¸ÑÑŒ Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½', 'ğŸ“ Ğ—Ğ°Ğ¿Ğ¸ÑÑŒ Ğ¿Ğ¾ Ğ·Ğ²Ğ¾Ğ½ĞºÑƒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°'],
      ['ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹']
    ])
    .resize()
  );
});

bot.hears('ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹', ctx => {
  ctx.reply(
    `Ğ¡Ğ²ÑĞ·ÑŒ Ñ Ñ€ĞµÑĞµĞ¿ÑˆĞ½ ÑÑ‚ÑƒĞ´Ğ¸Ğ¸:
    Ğ¡Ğ²Ğ¾Ğ±Ğ¾Ğ´Ñ‹ 6 â€” +7-928-40-85-968
    Ğ’Ğ¸Ğ´Ğ¾Ğ²Ğ° 210Ğ” â€” +7-993-32-12-000
    Ğ”Ğ·ĞµÑ€Ğ¶Ğ¸Ğ½ÑĞºĞ¾Ğ³Ğ¾ 211/2 â€” +7-993-30-10-137`
  );
});

bot.hears('ĞĞµÑ‚, Ğ²Ğ²ĞµÑÑ‚Ğ¸ Ğ´Ñ€ÑƒĞ³Ğ¾Ğµ Ğ¸Ğ¼Ñ', async ctx => {
  awaitingCustomName.add(ctx.chat.id);
  await ctx.reply('ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ, ĞºĞ°Ğº Ğº Ğ²Ğ°Ğ¼ Ğ¾Ğ±Ñ€Ğ°Ñ‰Ğ°Ñ‚ÑŒÑÑ:');
});

bot.on('text', async (ctx) => {
  await addUser(ctx.from.id, ctx.from.first_name, ctx.from.username);
  
  // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ Ñ ÑƒĞ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸ĞµĞ¼ Ğ±Ğ¾Ñ‚Ğ° Ğ² Ğ³Ñ€ÑƒĞ¿Ğ¿Ğµ
  const text = ctx.message.text;
  const botUsername = ctx.botInfo.username;
  
  if (text.startsWith(`/update_schedule@${botUsername}`)) {
    console.log('ğŸ“ ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° update_schedule Ñ ÑƒĞ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ° Ğ¾Ñ‚:', ctx.chat.id);
    
    if (!(await isAdminUser(ctx))) {
      console.log('âŒ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ°Ğ´Ğ¼Ğ¸Ğ½');
      return ctx.reply('âŒ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ»Ñ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ ÑÑ‚Ğ¾Ğ¹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹');
    }
    
    console.log('âœ… ĞĞ´Ğ¼Ğ¸Ğ½ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½, Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ² Ğ¾Ğ¶Ğ¸Ğ´Ğ°Ğ½Ğ¸Ğµ');
    awaitingScheduleUpload.add(ctx.chat.id);
    return ctx.reply('ğŸ“¤ ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ Ñ„Ğ°Ğ¹Ğ» Excel Ñ Ñ€Ğ°ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸ĞµĞ¼ Ğ´Ğ»Ñ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ');
  }
  
  if (text.startsWith(`/cancel_schedule@${botUsername}`)) {
    console.log('ğŸ“ ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° cancel_schedule Ñ ÑƒĞ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ° Ğ¾Ñ‚:', ctx.chat.id);
    
    if (!(await isAdminUser(ctx))) {
      return ctx.reply('âŒ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ»Ñ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ ÑÑ‚Ğ¾Ğ¹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹');
    }
    
    if (awaitingScheduleUpload.has(ctx.chat.id)) {
      awaitingScheduleUpload.delete(ctx.chat.id);
      ctx.reply('âŒ Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ñ€Ğ°ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ°');
    } else {
      ctx.reply('â„¹ï¸ Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ñ€Ğ°ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ Ğ½Ğµ Ğ±Ñ‹Ğ»Ğ° Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ°');
    }
    return;
  }
  
  // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ users_count Ñ ÑƒĞ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸ĞµĞ¼
  if (text.startsWith(`/users_count@${botUsername}`)) {
    console.log('ğŸ“ ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° users_count Ñ ÑƒĞ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ° Ğ¾Ñ‚:', ctx.chat.id);

    if (!(await isAdminUser(ctx))) {
      return ctx.reply('âŒ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ»Ñ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ ÑÑ‚Ğ¾Ğ¹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹');
    }

    try {
      const count = await getUsersCount();
      return ctx.reply(`ğŸ‘¥ Ğ’ÑĞµĞ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ±Ğ¾Ñ‚Ğ°: ${count}`);
    } catch (err) {
      console.error('âŒ Failed to get user count:', err);
      return ctx.reply('âš ï¸ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğ¸ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹');
    }
  }
  
  // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ broadcast Ñ ÑƒĞ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸ĞµĞ¼
  if (text.startsWith(`/broadcast@${botUsername}`)) {
    console.log('ğŸ“ ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° broadcast Ñ ÑƒĞ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ° Ğ¾Ñ‚:', ctx.chat.id);
    
    if (!(await isAdminUser(ctx))) {
      return ctx.reply('âŒ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ»Ñ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ ÑÑ‚Ğ¾Ğ¹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹');
    }
    
    awaitingBroadcast.add(ctx.chat.id);
    return ctx.reply('ğŸ“¢ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸ Ğ²ÑĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼:');
  }
  
  // ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒÑĞºĞ¾Ğ³Ğ¾ Ğ¸Ğ¼ĞµĞ½Ğ¸
  if (awaitingCustomName.has(ctx.chat.id)) {
    const customName = ctx.message.text;
    await setUserName(ctx.chat.id, customName);
    awaitingCustomName.delete(ctx.chat.id);
    
    await ctx.replyWithPhoto({ source: NEXT_PHOTO });
    await ctx.reply(
      `ĞŸÑ€Ğ¸ÑÑ‚Ğ½Ğ¾ Ğ¿Ğ¾Ğ·Ğ½Ğ°ĞºĞ¾Ğ¼Ğ¸Ñ‚ÑŒÑÑ, ${customName}! Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ:`,
      Markup.keyboard([
        ['ğŸ–¥ï¸ Ğ—Ğ°Ğ¿Ğ¸ÑÑŒ Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½', 'ğŸ“ Ğ—Ğ°Ğ¿Ğ¸ÑÑŒ Ğ¿Ğ¾ Ğ·Ğ²Ğ¾Ğ½ĞºÑƒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°'],
        ['ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹']
      ])
      .resize()
    );
    return;
  }
  
  // ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸
  if (awaitingBroadcast.has(ctx.chat.id)) {
    if (!(await isAdminUser(ctx))) {
      awaitingBroadcast.delete(ctx.chat.id);
      return ctx.reply('âŒ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ»Ñ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ ÑÑ‚Ğ¾Ğ¹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹');
    }
    
    const broadcastMessage = text;
    awaitingBroadcast.delete(ctx.chat.id);
    
    await ctx.reply('ğŸ“¤ ĞĞ°Ñ‡Ğ¸Ğ½Ğ°Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºÑƒ...');
    
    let successCount = 0;
    let errorCount = 0;
    
    const allUsers = await getAllUsers();
    
    for (const userId of allUsers) {
      try {
        await sendMessageToUser(userId, broadcastMessage);
        successCount++;
        await new Promise(resolve => setTimeout(resolve, 50));
      } catch (error) {
        errorCount++;
        console.error(`Failed to send message to user ${userId}:`, error.message);
        
        if (error.message.includes('blocked') || error.message.includes('user not found') || error.message.includes('chat not found')) {
          await removeUser(userId);
        }
      }
    }
    
    const finalCount = await getUsersCount();
    await ctx.reply(`âœ… Ğ Ğ°ÑÑÑ‹Ğ»ĞºĞ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°!\nğŸ“Š Ğ£ÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾: ${successCount}\nâŒ ĞÑˆĞ¸Ğ±Ğ¾Ğº: ${errorCount}\nğŸ‘¥ ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹: ${finalCount}`);
    return;
  }
});

bot.command('contacts', ctx => {
  ctx.reply(
    `Ğ¡Ğ²ÑĞ·ÑŒ Ñ Ñ€ĞµÑĞµĞ¿ÑˆĞ½ ÑÑ‚ÑƒĞ´Ğ¸Ğ¸:
  Ğ¡Ğ²Ğ¾Ğ±Ğ¾Ğ´Ñ‹ 6 â€” +7-928-40-85-968
  Ğ’Ğ¸Ğ´Ğ¾Ğ²Ğ° 210Ğ” â€” +7-993-32-12-000
  Ğ”Ğ·ĞµÑ€Ğ¶Ğ¸Ğ½ÑĞºĞ¾Ğ³Ğ¾ 211/2 â€” +7-993-30-10-137`
  );
});

// Ğ˜ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ğ°Ñ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° update_schedule
bot.command('update_schedule', async (ctx) => {
  console.log('ğŸ“ ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° update_schedule Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ° Ğ¾Ñ‚:', ctx.chat.id, 'ADMIN_CHAT_ID:', ADMIN_CHAT_ID);
  console.log('ğŸ” Ğ¢Ğ¸Ğ¿ Ñ‡Ğ°Ñ‚Ğ°:', ctx.chat.type);
  
  if (!(await isAdminUser(ctx))) {
    console.log('âŒ ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğµ Ğ°Ğ´Ğ¼Ğ¸Ğ½');
    return ctx.reply('âŒ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ»Ñ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ ÑÑ‚Ğ¾Ğ¹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹');
  }
  
  console.log('âœ… ĞĞ´Ğ¼Ğ¸Ğ½ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½, Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ² Ğ¾Ğ¶Ğ¸Ğ´Ğ°Ğ½Ğ¸Ğµ');
  awaitingScheduleUpload.add(ctx.chat.id);
  console.log('ğŸ“‹ Ğ¢ĞµĞºÑƒÑ‰Ğ¸Ğ¹ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ¾Ğ¶Ğ¸Ğ´Ğ°ÑÑ‰Ğ¸Ñ…:', Array.from(awaitingScheduleUpload));
  
  await ctx.reply('ğŸ“¤ ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ Ñ„Ğ°Ğ¹Ğ» Excel Ñ Ñ€Ğ°ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸ĞµĞ¼ Ğ´Ğ»Ñ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ\n\nâš ï¸ Ğ£Ğ±ĞµĞ´Ğ¸Ñ‚ĞµÑÑŒ, Ñ‡Ñ‚Ğ¾ Ñ„Ğ°Ğ¹Ğ» ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ ĞºĞ¾Ğ»Ğ¾Ğ½ĞºĞ¸: date, time, direction, address');
});

// ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½Ñ‹ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ Ñ€Ğ°ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ
bot.command('cancel_schedule', async (ctx) => {
  console.log('ğŸ“ ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° cancel_schedule Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ° Ğ¾Ñ‚:', ctx.chat.id);
  
  if (!(await isAdminUser(ctx))) {
    return ctx.reply('âŒ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ»Ñ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ ÑÑ‚Ğ¾Ğ¹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹');
  }
  
  if (awaitingScheduleUpload.has(ctx.chat.id)) {
    awaitingScheduleUpload.delete(ctx.chat.id);
    ctx.reply('âŒ Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ñ€Ğ°ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ°');
  } else {
    ctx.reply('â„¹ï¸ Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ñ€Ğ°ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ Ğ½Ğµ Ğ±Ñ‹Ğ»Ğ° Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ°');
  }
});

// ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ° ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
bot.command('users_count', async (ctx) => {
  if (!(await isAdminUser(ctx))) {
    return ctx.reply('âŒ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ»Ñ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ ÑÑ‚Ğ¾Ğ¹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹');
  }
  
  try {
    const count = await getUsersCount();
    return ctx.reply(`ğŸ‘¥ Ğ’ÑĞµĞ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ±Ğ¾Ñ‚Ğ°: ${count}`);
  } catch (err) {
    console.error('âŒ Failed to get users count:', err);
    return ctx.reply('ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğ¸ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹.');
  }
});

// ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° Ğ´Ğ»Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸
bot.command('broadcast', async (ctx) => {
  if (!(await isAdminUser(ctx))) {
    return ctx.reply('âŒ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ»Ñ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ ÑÑ‚Ğ¾Ğ¹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹');
  }
  
  awaitingBroadcast.add(ctx.chat.id);
  ctx.reply('ğŸ“¢ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ¸ Ğ²ÑĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼:');
});

// Ğ£Ğ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
bot.on('document', async (ctx) => {
  console.log('ğŸ“„ Document received from:', ctx.chat.id);
  console.log('ğŸ“‹ Awaiting upload list:', Array.from(awaitingScheduleUpload));
  
  if (!awaitingScheduleUpload.has(ctx.chat.id)) {
    console.log('âŒ User not in awaiting list');
    return;
  }
  
  if (!(await isAdminUser(ctx))) {
    console.log('âŒ User is not admin');
    return;
  }

  awaitingScheduleUpload.delete(ctx.chat.id);
  
  try {
    const fileName = ctx.message.document.file_name;
    console.log('ğŸ“„ Processing file:', fileName);
    
    if (!fileName.endsWith('.xlsx') && !fileName.endsWith('.xls')) {
      return ctx.reply('âŒ ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ Ñ„Ğ°Ğ¹Ğ» Excel (.xlsx Ğ¸Ğ»Ğ¸ .xls)');
    }

    await ctx.reply('â³ ĞĞ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°Ñ Ñ„Ğ°Ğ¹Ğ» Ñ€Ğ°ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ...');

    const fileLink = await ctx.telegram.getFileLink(ctx.message.document.file_id);
    console.log('ğŸ”— File link obtained:', fileLink.href);
    
    const response = await fetch(fileLink.href);
    const buffer = await response.buffer();
    console.log('ğŸ“¦ Buffer size:', buffer.length, 'bytes');

    const result = await updateScheduleFromBuffer(buffer);
    
    await ctx.reply(`âœ… Ğ Ğ°ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾!\nğŸ“Š Ğ—Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ğ¾ Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹: ${result.processedRows}\nğŸ¢ Ğ¡Ñ‚ÑƒĞ´Ğ¸Ğ¹: ${Object.keys(result.newSchedules).length}\nâš ï¸ ĞÑˆĞ¸Ğ±Ğ¾Ğº Ğ² ÑÑ‚Ñ€Ğ¾ĞºĞ°Ñ…: ${result.errorRows}`);
    
  } catch (error) {
    console.error('âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞµ Ñ„Ğ°Ğ¹Ğ»Ğ°:', error);
    ctx.reply(`âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: ${error.message}`);
  }
});

bot.command('check_schedules', async (ctx) => {
  if (!(await isAdminUser(ctx))) {
    return ctx.reply('âŒ Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ»Ñ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ ÑÑ‚Ğ¾Ğ¹ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹');
  }
  
  const addressCount = Object.keys(schedules).length;
  const totalSlots = Object.values(schedules).reduce((sum, arr) => sum + arr.length, 0);
  
  let message = `ğŸ“Š Ğ¢ĞµĞºÑƒÑ‰ĞµĞµ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ñ€Ğ°ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğ¹:\n`;
  message += `ğŸ¢ Ğ¡Ñ‚ÑƒĞ´Ğ¸Ğ¹: ${addressCount}\n`;
  message += `ğŸ“… Ğ’ÑĞµĞ³Ğ¾ ÑĞ»Ğ¾Ñ‚Ğ¾Ğ²: ${totalSlots}\n\n`;
  
  if (addressCount > 0) {
    message += `Ğ¡Ñ‚ÑƒĞ´Ğ¸Ğ¸:\n`;
    Object.keys(schedules).forEach(address => {
      message += `â€¢ ${address}: ${schedules[address].length} ÑĞ»Ğ¾Ñ‚Ğ¾Ğ²\n`;
    });
  } else {
    message += `âŒ Ğ Ğ°ÑĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ñ Ğ½Ğµ Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ñ‹`;
  }
  
  await ctx.reply(message);
});

bot.on('contact', async ctx => {
  const chatId = ctx.chat.id;
  
  await addUser(ctx.from.id, ctx.from.first_name, ctx.from.username);
  
  // Clear reminders if exist
  if (pendingReminders.has(chatId)) {
    const {t3, t15, t24 } = pendingReminders.get(chatId);
    clearTimeout(t3);
    clearTimeout(t15);
    clearTimeout(t24);
    pendingReminders.delete(chatId);
  }

  const { first_name, phone_number } = ctx.message.contact;
  const telegram_id = ctx.from.id;
  
  // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ½Ğ¾Ğµ Ğ¸Ğ¼Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¸Ğ»Ğ¸ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ğ¸Ğ¼Ñ Ğ¸Ğ· ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ğ°
  const userName = await getUserName(chatId) || first_name;
  
  // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ + Ğº Ğ½Ğ¾Ğ¼ĞµÑ€Ñƒ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°, ĞµÑĞ»Ğ¸ ĞµĞ³Ğ¾ Ğ½ĞµÑ‚
  const formattedPhone = phone_number.startsWith('+') ? phone_number : `+${phone_number}`;
  
  // Get stored booking data
  const bookingData = pendingBookings.get(telegram_id);
  
  if (bookingData) {
    // This is a form submission - send complete booking data
    const msg = `ĞĞ¾Ğ²Ğ°Ñ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ½Ğ°Ñ Ğ·Ğ°ÑĞ²ĞºĞ°:
      Ğ¦ĞµĞ»ÑŒ: ${bookingData.goal}
      ĞĞ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ: ${bookingData.direction}
      Ğ¡Ñ‚ÑƒĞ´Ğ¸Ñ: ${bookingData.address}
      Ğ¡Ğ»Ğ¾Ñ‚: ${bookingData.slot || 'Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½'}
      Ğ˜Ğ¼Ñ: ${userName}
      Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: ${formattedPhone}
      ID: ${telegram_id}`;
      
    await bot.telegram.sendMessage(ADMIN_CHAT_ID, msg);
    pendingBookings.delete(telegram_id);
  } else {
    // This is a callback request
    const msg = `ĞĞ¾Ğ²Ğ°Ñ Ğ·Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ½Ñ‹Ğ¹ Ğ·Ğ²Ğ¾Ğ½Ğ¾Ğº:
      Ğ˜Ğ¼Ñ: ${userName}
      Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: ${formattedPhone}
      ID: ${telegram_id}`;
      
    await bot.telegram.sendMessage(ADMIN_CHAT_ID, msg);
  }
  
  await ctx.reply('Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾! ĞœÑ‹ Ğ¿ĞµÑ€ĞµĞ·Ğ²Ğ¾Ğ½Ğ¸Ğ¼ Ğ²Ğ°Ğ¼ Ğ² Ğ±Ğ»Ğ¸Ğ¶Ğ°Ğ¹ÑˆĞµĞµ Ğ²Ñ€ĞµĞ¼Ñ.', Markup.removeKeyboard());
});

// Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ¸ Ğ´Ğ»Ñ Ğ²ÑĞµÑ… Ğ¾ÑÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğ¹ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹
bot.hears(/.*/, async (ctx) => {
  // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¿Ñ€Ğ¸ Ğ»ÑĞ±Ğ¾Ğ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¸
  await addUser(ctx.from.id, ctx.from.first_name, ctx.from.username);
});

bot.on('callback_query', async (ctx) => {
  // Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¿Ñ€Ğ¸ Ğ½Ğ°Ğ¶Ğ°Ñ‚Ğ¸Ğ¸ Ğ½Ğ° ĞºĞ½Ğ¾Ğ¿ĞºĞ¸
  await addUser(ctx.from.id, ctx.from.first_name, ctx.from.username);
});


// Endpoints
app.post('/slots', (req, res) => {
  const { direction, address, days = 3 } = req.body;
  const now = new Date();
  const targetDate = new Date();
  targetDate.setDate(targetDate.getDate() + days);

  const arr = schedules[address] || [];

  const slots = arr
    .filter(slot => {
      const slotDateTime = new Date(`${slot.date}T${slot.time}`);
      const match = slot.direction.trim() === direction.trim();
      
      return match && !isNaN(slotDateTime.getTime()) && slotDateTime >= now && slotDateTime <= targetDate;
    })
    .map(slot => ({ date: slot.date, time: slot.time }))
    .sort((a, b) => {
      const dateA = new Date(`${a.date}T${a.time}`);
      const dateB = new Date(`${b.date}T${b.time}`);
      return dateA - dateB;
    });

  res.json({ ok: true, slots });
});

// Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ endpoint Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ¸Ğ¼ĞµĞ½Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
app.get('/user-name/:telegram_id', async (req, res) => {
  const telegramId = parseInt(req.params.telegram_id);
  const userName = await getUserName(telegramId);
  
  res.json({ 
    ok: true, 
    name: userName 
  });
});

app.post('/submit', async (req, res) => {
  try {
    const bookingData = req.body;
    // Store booking data
    pendingBookings.set(bookingData.telegram_id, bookingData);
    
    await bot.telegram.sendMessage(
      bookingData.telegram_id,
      'Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾! Ğ”Ğ»Ñ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ, Ğ¿Ğ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¿Ğ¾Ğ´ĞµĞ»Ğ¸Ñ‚ĞµÑÑŒ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ğ¾Ğ¼.',
      {
        reply_markup: {
          keyboard: [[{ text: 'ğŸ“² ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ', request_contact: true }]],
          resize_keyboard: true,
          one_time_keyboard: true
        }
      }
    );
    
    res.json({ ok: true });
  } catch (err) {
    console.error('Error in /submit:', err);
    res.status(500).json({ ok: false, error: err.message });
  }
});

async function sendBookingToAdmin(bookingData) {
  const { goal, direction, address, name, phone, slot, telegram_id } = bookingData;
  
  const msg = `ĞĞ¾Ğ²Ğ°Ñ Ğ¾Ğ½Ğ»Ğ°Ğ¹Ğ½-Ğ·Ğ°ÑĞ²ĞºĞ°:
    Ğ¦ĞµĞ»ÑŒ: ${goal}
    ĞĞ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ: ${direction}
    Ğ¡Ñ‚ÑƒĞ´Ğ¸Ñ: ${address}
    Ğ¡Ğ»Ğ¾Ñ‚: ${slot || 'Ğ½Ğµ ÑƒĞºĞ°Ğ·Ğ°Ğ½'}
    Ğ˜Ğ¼Ñ: ${name}
    Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: ${phone}
    ID: ${telegram_id}`;
    
  return await bot.telegram.sendMessage(ADMIN_CHAT_ID, msg);
}

const isProd = process.env.NODE_ENV === 'production';

console.log(`ğŸ”§ Ğ ĞµĞ¶Ğ¸Ğ¼ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ°: ${isProd ? 'PRODUCTION (webhook)' : 'DEVELOPMENT (polling)'}`);

// Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ ÑÑ‚Ğ¸ Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚Ñ‹ Ğ¿ĞµÑ€ĞµĞ´ if (isProd)
app.get('/', (req, res) => {
  res.send('<h1>Server Works!</h1>');
});

app.get('/test', (req, res) => {
  res.json({ status: 'ok', time: new Date() });
});

console.log('ğŸš€ Starting server...');
app.listen(PORT, '0.0.0.0', () => {
  console.log(`âœ… Server running on port ${PORT}`);
}).on('error', (err) => {
  console.error('âŒ Server error:', err);
});
